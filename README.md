# Euler-Project
My solutions and programs on Euler Project Problem

# 评等要求

★:算法应当能成功作答，但囿于太过复杂导致无法在可接受时间内完成

★★:成功作答，但运行时间超过60s

★★★:成功作答，并且运行时间在60s以内(Euler Project要求)

★★★★:成功作答，并且运行时间在10s以内

★★★★★:成功作答，并且运行时间在1s以内

# 问题列表

## Problem 1(Python, cost < 0.001s) ★★★★★
### Answer: 233168

统计1000以内3或5的倍数之和，直接搜索一遍1000以内的数即可，非常简单

## Problem 2(Python, cost < 0.001s) ★★★★★
### Answer: 4613732

四百万以下的偶斐波那契数求和，直接采用递推公式计算斐波那契数（偶数每3个数出现一次），累和即可

## Problem 3(Python, cost = 0.017s) ★★★★★
### Answer: 6857

求一个大整数的最大质因子，基本想法是从小到大用各个质数除这个大整数，直到除不尽为止，当商为1时，即为最大正整数。

## Problem 4(Python, cost = 0.291s) ★★★★★
### Answer: 906609

求两个三位数的积构成的最大回文数，基本想法就是遍历900 * 900 = 810000 种可能，不过注意到该回文数必为11倍数，所以削减为原来搜索范围的1/11，然后直接搜索即可。

## Problem 5(Python, cost < 0.001s) ★★★★★
### Answer: 23279256

求1,...,20的最小公倍数。一个简单的想法是两两求最小公倍数，算法复杂度大概是log(N) * log(N),其实已经很快了。我在这时比较懒，所以直接用循环分解质因数求解，也省得写个辗转相除了。

## Problem 6(Python, cost < 0.001s) ★★★★★
### Answer: 25164150

计算100以内数平方和与和的平方之差，如果懒一点，直接用公式就好;如果勤奋些，可以写个循环累和。

## Problem 7(Python, cost = 0.569s) ★★★★★
### Answer: 104743

求第10001个质数，直接挨个搜寻，直到找到10001个为止


## Problem 9(Python, cost = 0.222s) ★★★★★
### Answer: 31875000

寻找一个直角三角形，使得其周长之和为1000.直接搜索未免范围太大，所以采用“两边之和大于第三边，两边之差小于第三边”进行约束，可以得到比较理想的搜索域。
然后直接暴力搜索即可。

## Problem 10(Python, cost = 1.69s) ★★★★
### Answer: 142913828922

打表求质数（一个个判断很慢），然后一个个累和即可

## Problem 12(Python, cost = 0.485s) ★★★★★
### Answer: 76576500

题目需要求拥有超过500因子的三角数(n * (n + 1) / 2),那么如果对三角数进行一个个因子的试除比较慢，所以采用 因子个数 = (x1 + 1) * ... * (xn + 1)，其中x1,...,xn为其质因数分解的各质因子的幂次，加上超过500因子，所以该数一定大于250^2(考虑因子成对)，进一步压缩搜索范围，然后开始搜索即可。

## Problem 13(Python, cost < 0.001s) ★★★★★
### Answer: 5537376230

利用python简单求和……然后取最高10位为结果即可。

## Problem 14(Python, cost =39.7s) ★★★
### Answer: 837799

求解collatz猜想(又称冰雹猜想)中1000000以内，雹程最长的数。一个朴素的想法是挨个计算每个数的雹程;另一种想法就是一条一条递归计算(只记录起始数及其雹程)，两种方法不清楚谁会更快。

## Problem 15(Python, cost = 0.002s) ★★★★★
### Answer: 137846528820

首先考虑上方和左方的边结点，显然只有一条路可以走，所以标记为1；接下来考虑中间的节点，可以发现到达其路径条数为其上方和左方节点路径数之和，所以通过简单的递推就可以求解。


## Problem 16(Python, cost < 0.001s) ★★★★★
### Answer: 1366

计算2 ^ 1000的各位数字和……没啥技巧，利用python自带的大整数计算，然后逐个数位累和即可，没啥技术含量。

## Problem 18(Python, cost = 0.017s) ★★★★★
### Answer: 1074

金字塔内寻找路径和最大的路径，采用DFS简单搜索即可得出结果。

## Problem 19(Python, cost < 0.001s) ★★★★★
### Answer: 171

计算20世纪内星期日的个数，一个简单的想法就是直接遍历计数，需要注意的一个问题是闰年，其他都很简单。

## Problem 21(Python, cost = 0.138s) ★★★★★
### Answer: 36126

寻找10000以下亲和数(数A的因子和是数B, 数B的因子和是数A)之和。其实只要记录每个数的因子和，然后两两比较（排序也可）就可以找出亲和数，最后累和即可。

## Problem 22(Python, cost = 0.0289s) ★★★★★
### Answer: 871198282

输入文件，统计每个名字根据题设所得分数，最后累和即可

## Problem 27(Python, cost = 0.873s) ★★★★★
### Answer: -59231

暴力求解即可

## Problem 28(Python, cost < 0.001s) ★★★★★
### Answer: 665168997

数列求和问题，简单暴力求解即可

## Problem 29(Python, cost = 0.0110s) ★★★★★
### Answer: 9183

根据python集合（set）元素互异的特性，直接计算所有值并置于同一集合中，取集合大小即为答案

## Problem 31(Python, cost = 0.050s) ★★★★★
### Answer: 73682

问题也即求解不定方程:x1 + 2x2 + 5x3 + 10x4 + 20x5 + 50x6 + 100x7 = 200 的整数解，简单想法用贪心/递归都可以实现。

## Problem 35(Python, cost = 8.84s) ★★★★
### Answer: 55

## Problem 38(Python, cost = 0.0638s) ★★★★★
### Answer: 932718654

## Problem 44(Python, cost = 38.7s) ★★★
### Answer: 5482660

## Problem 45(Python, cost = 0.056s) ★★★★★
### Answer: 1533776805

这题的目标是找到一个大于40755的数X,使其满足X = N * (N - 1) / 2 = M * (3 * M - 1) / 2 = L * (2 * L - 1).单纯一个个算出来比对是不靠谱的，我们显然可以发现，最后一种表示方式增长最快(分布最稀疏)，而且令L = 2 * N就可以发现第一种和第三种表示是相同的。因此我们将它作为标准，代入方程，反解出M,看是不是正整数即可。

## Problem 46(Python, cost = 0.095s) ★★★★★
### Answer: 5777

题目要求找出最小的奇合数n，使得其不能写成n = p + 2 * p ^ 2(p为素数)的形式。显然，在对素数打表的过程中，我们可以一次标注出素数和奇合数来。通过观察可以发现，对于每个奇素数n，使得该式成立的p必小于n的算术平方根。在前述条件下直接依次搜索即可。

## Problem 47(Python, cost = 0.196s) ★★★★★
### Answer: 134043
这是一个非常朴素的题目，题目让我们找出最小且连续的4个正整数，使得每个正整数都恰有4个互异的正因子。

思路也非常明确，直接打表搜索1-MAX(MAX为人为规定上界)内的正整数互异正因子个数，然后再跑一遍全列表，判断连续4个数是否满足题设。

其实还有可以提升的地方，比如在寻找连续4个数时，用KMP算法的思想会更快一些，不过也已经达到了设定最高要求，有兴趣的话可以改进一下。

## Problem 53(Python, cost = 0.0152s) ★★★★★
### Answer: 4075

计算组合数的关键在于计算，如果单纯采用计算阶乘的方法，显然是十分复杂的，而且每个数都要计算一遍，会占用很多时间。
在这里我们采用杨辉三角来递推组合数，不难证明，杨辉三角第N行从左数第M个对应于组合数C（N，M），而C（N，M）= C（N - 1, M）+ C（N - 1, M - 1）
那么很快就可以计算出来，再根据题设条件计数就好。

## Problem 55(Python, cost = 0.0927s) ★★★★★
### Answer = 249

## Problem 56(Python, cost = 0.357s) ★★★★★
### Answer = 972

## Problem 62(Python, cost = 9.65s) ★★★★
### Answer = 127035954683

## Problem 63(Python, cost < 0.001s) ★★★★★
### Answer = 49

## Problem 69(Python, cost < 0.001s) ★★★★★
### Answer = 510510

## Problem 76(Python, cost = 118s) ★★
### Answer = 190569291

## Problem 80(Python, cost = 0.176s) ★★★★★
### Answer = 40886

题目要求计算100内非完全平方数，其平方根结果的前100位数字之和的累加(实在是比较拗口)。一个很简单的想法是直接利用python不限位数的计算，然而很可惜精度不足。所以说要努力将平方根求解化归为大整数运算，采用二分搜索寻找结果。考虑到算法量级为log2(n), n = √m * 10 ^ 100, 所以实际运算复杂度还好，直接求解即可。

## Problem 85(Python, cost = 0.029s) ★★★★★
### Answer = 2772

题目要求计算一个网格中长方形的个数最接近2000000的长方形面积大小。第一个考虑是对边界进行预估，考虑到长方形长宽互换情况相同，不妨假定长a,宽b且a > b。
一个极限考虑是一个b = 1的长方形，若要接近目标，其上限为n = 2000(此时长方形总数为2000 * (2000 + 1) / 2 > 2000000)，因此可以得出n = 2000 > a > b是我们的搜索域。 
这样显然是不太好的，因为计算量大约是O(n ^ 3)，我们需要进一步压缩。想到当a确定时，长方形个数关于b单调递增，于是我们可以关于b采用二分搜索的方法，这样就将运算量降至O(n ^ 2 * log n)，可喜可贺。
最后一点是关于长方形个数计算的，不难发现长方形总数为a * (a + 1) / 2 * b * (b + 1) / 2，可以实现常数级运算。

## Problem 87(Python, cost = 1.701s) ★★★★
### Answer = 109743

本题目的在于求解50 000 000以下一类数的个数，这类数能够写成a = x ^ 2 + y ^ 3 + z ^ 4(x, y, z均为质数)的形式，一个简单的想法就是x, y, z必不超过√50 000 000,所以简单求解其中的质数，进行穷举即可。要注意的是，最好根据上限适当剪枝，提升运算效率。

## Problem 92(Python, cost = 58.1s) ★★★
### Answer = 8581147

## Problem 97(Python, cost = 0.454s) ★★★★★
### Answer = 8739992577

## Problem 206(Python, cost = 12.8s) ★★★
### Answer = 1389019170

本题目的是要求一个给定的正整数使其为一个完全平方数。根据题意，可以发现直接搜索的范围是10 ^ 9，这个代价比较大，需要进行剪枝。可以发现末尾是0，所以根据完全平方数的性质，可以得出最后一个空位应该是0，也可递推出倒数第二个空位只能是3或7，这样就缩小了20倍，最后我们对其开根号的结果进行搜索而不是原数搜索，同样可以减小搜索范围，得到一个比较好的结果。

## Problem 346(Python, cost = 3.44s) ★★★★
### Answer = 336108797689259276

本题目的是求在不同进制下能够被表征为全1序列的正整数之和。显然自然数N显然能在N - 1进制下满足此要求，于是只需要再寻求另一种不同进制的情况即可。考虑到N = 1 + A + ... + A ^ M(M > 1)为其充要条件，因此可以将其化归为等比数列求和问题。然而还有一个问题，那就是重复计算的问题，例如31 = 1 + 2 + 4 + 8 + 16 = 1 + 5 + 25，令人头疼。但是如果逐个计算……那么范围在10 ^ 9时所需时间 > 1s，达到题设要求大概需要1000s以上，很难让人接受。根据Goormaghtigh猜想，31和8191是唯一的两个特例，因此把他们挑出来之后就可以大胆使用上述方法了。
